/*
 * Copyright (C) 2015- Supership Inc.
 */
package jp.supership.elasticsearch.plugin.queryparser.classic;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.tree.ParseTree;
import org.apache.lucene.queryparser.classic.ParseException;
import org.apache.lucene.search.BooleanClause;
import org.apache.lucene.search.Query;
import jp.supership.elasticsearch.plugin.queryparser.antlr4.handler.HandleException;
import jp.supership.elasticsearch.plugin.queryparser.antlr4.handler.QueryHandler;
import jp.supership.elasticsearch.plugin.queryparser.dsl.QueryBaseVisitor;
import jp.supership.elasticsearch.plugin.queryparser.dsl.QueryLexer;
import jp.supership.elasticsearch.plugin.queryparser.dsl.QueryParser;
import jp.supership.elasticsearch.plugin.queryparser.classic.intermediate.QueryEngine;
import jp.supership.elasticsearch.plugin.queryparser.util.StringUtils;

/**
 * This class is responsible for handling query parser generated by ANTLR4 and dispatches internal
 * Lucene APIs through the internal QueryEngine implementation.
 * The utilizing parser is generated by {@code jp.supership.elasticsearch.plugin.dsl.Query#g4},
 * hence the corresponding grammer is for "user land" queries.
 *
 * @author Shingo OKAWA
 * @since  1.0
 */
public class DSQHandler extends QueryBaseVisitor<Query> implements QueryHandler {
    /**
     * Represents domain specific query context, besides holding the query constructing settings
     * this class is also responsible to maintain the currently constructing {@code Query} instance
     * which will be handled with the {@code DSQHandler.Engine}.
     */
    private class Context extends QueryHandler.Context {
	/** Holds currently constructing query. */
	public Query query = null;
	/** Holds constructing clauses. */
	public List<BooleanClause> clauses = new ArrayList<BooleanClause>();
    }

    /**
     * This class is responsible for instanciating Lucene queries from the Supership, inc. Domain Specific Query.
     */
    private class Engine extends QueryEngine {
        /** Holds query engine which is reponsible for parsing raw query strings. */
        private QueryHandler handler;

        /**
         * {@inheritDoc}
         */
        @Override
        public Query handle(String defaultField) throws HandleException {
            return this.handler.handle(defaultField);
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public Query dispatch(QueryHandler.Context context) throws HandleException {
            Query query;

            try {
                if (context.wildcard) {
                    query = this.getWildcardQuery(context.field, context.term);
                } else if (context.prefix) {
                    query = this.getPrefixQuery(context.field, StringUtils.discardEscapeChar(context.term.substring(0, context.term.length() - 1)));
                } else if (context.regexp) {
                    query = this.getRegexpQuery(context.field, context.term.substring(1, context.term.length() - 1));
                } else if (context.fuzzy) {
                    query = this.forwardFuzzyQuery(context.field, context.fuzzySlop, context.term);
                } else {
                    query = this.getFieldQuery(context.field, context.term, false);
                }
            } catch (ParseException cause) {
                throw new HandleException(cause);
            }

            return query;
        }

        /**
         * Forwarding to {@code getFuzzyQuery} method with assigned minimum similarity value.
	 * @param  field the currently handling field.
	 * @param  fuzzySlop the currently handling fuzzly slop term.
	 * @param  term  the currently handling term.
	 * @throws ParseException if the parsing fails.
         */
        private Query forwardFuzzyQuery(String field, String fuzzySlop, String term) throws ParseException {
            float fuzzyMinSim = this.getFuzzyMinSim();

            try {
                // TODO: bit legacy code, so depends on the JRE version, fix this code.
                fuzzyMinSim = Float.valueOf(fuzzySlop.substring(1)).floatValue();
            } catch (Exception ignorance) {
                // DO NOTHING, the value has its default, so this is safe.
            }

            if (fuzzyMinSim < 0.0f) {
                throw new ParseException("minimum similarity for a FuzzyQuery must be between 0.0f and 1.0f.");
            } else if (fuzzyMinSim >= 1.0f && fuzzyMinSim != (int) fuzzyMinSim) {
                throw new ParseException("fractional edit distances are not allowed.");
            }

            return this.getFuzzyQuery(field, term, fuzzyMinSim);
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public void fetch(InputStream input) {
            this.handler.fetch(input);
        }
    }

    /** Holds this handler's context. */
    private DSQHandler.Context context;

    /** Holds query engine which is reponsible for parsing raw query strings. */
    private QueryEngine engine;

    /** Holds query engine which is reponsible for parsing raw query strings. */
    private InputStream input;

    /**
     * {@inheritDoc}
     */
    @Override
    public Query visitQuery(QueryParser.QueryContext context) {
	while (context.clause() != null) {
	    //	    visit(context.clause());
	}
	if (this.context.clauses.size() == 1 /*&& do something on the first query here*/) {
	    return this.context.query; // must be the first query.
	} else {
	    try {
		return this.engine.getBooleanQuery(this.context.clauses);
	    } catch (Exception e) {
		return null;
	    }
	}
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Query visitClause(QueryParser.ClauseContext context) {
        return this.visitChildren(context);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Query visitExpression(QueryParser.ExpressionContext context) {
        return this.visitChildren(context);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Query visitStringTerm(QueryParser.StringTermContext context) {
        return this.visitChildren(context);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Query visitNumberTerm(QueryParser.NumberTermContext context) {
        return this.visitChildren(context);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Query visitSubQueryTerm(QueryParser.SubQueryTermContext context) {
        return this.visitChildren(context);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Query handle(String defaultField) throws HandleException {
        try {
	    // TODO: Check if a fast input stream must be implemented.
            ANTLRInputStream input = new ANTLRInputStream(this.input);
            QueryLexer lexer = new QueryLexer(input);
            CommonTokenStream tokens = new CommonTokenStream(lexer);
            QueryParser parser = new QueryParser(tokens);
            ParseTree tree = parser.query();
            return this.visit(tree);
        } catch (Exception cause) {
            throw new HandleException(cause);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Query dispatch(QueryHandler.Context context) throws HandleException {
        return this.engine.dispatch(context);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void fetch(InputStream input) {
        this.input = input;
    }
}
