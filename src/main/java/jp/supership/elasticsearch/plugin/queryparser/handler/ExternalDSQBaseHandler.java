/*
 * Copyright (C) 2015- Supership Inc.
 */
package jp.supership.elasticsearch.plugin.queryparser.handler;

import java.io.Reader;
import java.util.ArrayList;
import java.util.List;
import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.misc.ParseCancellationException;
import org.antlr.v4.runtime.tree.ParseTree;
import org.apache.lucene.search.BooleanClause;
import org.apache.lucene.search.Query;
import jp.supership.elasticsearch.plugin.queryparser.antlr.v4.dsl.QueryBaseVisitor;
import jp.supership.elasticsearch.plugin.queryparser.antlr.v4.dsl.QueryLexer;
import jp.supership.elasticsearch.plugin.queryparser.antlr.v4.dsl.QueryParser;
import jp.supership.elasticsearch.plugin.queryparser.antlr.v4.util.HandleException;
import jp.supership.elasticsearch.plugin.queryparser.antlr.v4.util.NamedQueryHandler;
import jp.supership.elasticsearch.plugin.queryparser.lucene.util.ParseException;
import jp.supership.elasticsearch.plugin.queryparser.lucene.util.QueryEngine;

/**
 * This class is responsible for handling query parser generated by ANTLR4 and delegates internal
 * Lucene APIs through the internal QueryEngine implementation.
 * The utilizing parser is generated by {@code jp.supership.elasticsearch.plugin.dsl.Query#g4},
 * hence the corresponding grammer is for "user land" queries.
 *
 * @author Shingo OKAWA
 * @since  1.0
 */
abstract class ExternalDSQBaseHandler extends QueryBaseVisitor<Query> implements NamedQueryHandler {
    /**
     * Represents domain specific query context, besides holding the query constructing settings
     * this class is also responsible to maintain the currently constructing {@code Query} instance
     * which will be handled with the {@code Engine}.
     */
    protected class Metadata extends QueryHandler.Context {
	/** Holds currently constructing query. */
	public Query query = null;
	/** Holds constructing clauses. */
	public List<BooleanClause> clauses = new ArrayList<BooleanClause>();
	/** Holds previously detected cunjuntion. */
	public int conjunction = -1;
	/** Holds previously detected modifier. */
	public int modifier = -1;
    }

    /** Holds this handler's context. */
    protected ExternalDSQBaseHandler.Metadata metadata = new ExternalDSQHandler.Metadata();

    /** Holds query engine which is reponsible for parsing raw query strings. */
    protected QueryEngine engine;

    /** Holds query engine which is reponsible for parsing raw query strings. */
    protected Reader input;

    /**
     * {@inheritDoc}
     */
    @Override
    public Query visitQuery(QueryParser.QueryContext context) {
	try {
	    for (QueryParser.ExpressionContext expression : context.expression()) {
		this.metadata.conjunction = context.conjunction == null ? QueryParser.CONJUNCTION_AND : context.conjunction.getType();
		this.metadata.query = visit(expression);
		this.engine.conjugate(this.metadata.clauses, this.metadata.conjunction, this.metadata.modifier, this.metadata.query);
	    }

	    if (this.metadata.clauses.size() == 1 && this.metadata.query != null) {
		return this.metadata.query;
	    } else {
		return this.engine.getBooleanQuery(this.metadata.clauses);
	    }
	} catch (Exception cause) {
	    throw new ParseCancellationException(cause);
	}
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Query visitExpression(QueryParser.ExpressionContext context) {
	try {
	    this.metadata.modifier = context.modifier == null ? QueryParser.MODIFIER_REQUIRE : context.modifier.getType();
	    this.metadata.field = context.FIELD().getText();
	    return visit(context.term());
	} catch (Exception cause) {
	    throw new ParseCancellationException(cause);
	}
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Query visitStringTerm(QueryParser.StringTermContext context) {
	try {
	    this.metadata.term = context.TERM_STRING().getText();
	    return this.dispatchQuotedToken(this.metadata);
	} catch (Exception cause) {
	    throw new ParseCancellationException(cause);
	}
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Query visitNumberTerm(QueryParser.NumberTermContext context) {
	try {
	    this.metadata.term = context.TERM_NUMBER().getText();
	    return this.dispatchBareToken(this.metadata);
	} catch (Exception cause) {
	    throw new ParseCancellationException(cause);
	}
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Query visitFieldTerm(QueryParser.FieldTermContext context) {
	try {
	    this.metadata.term = context.TERM_FIELD().getText();
	    return this.dispatchBareToken(this.metadata);
	} catch (Exception cause) {
	    throw new ParseCancellationException(cause);
	}
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Query visitSubQueryTerm(QueryParser.SubQueryTermContext context) {
	try {
	    return visit(context.query());
	} catch (Exception cause) {
	    throw new ParseCancellationException(cause);
	}
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Query handle(String defaultField) throws HandleException {
        try {
	    // TODO: Check if a fast input stream must be implemented.
            ANTLRInputStream input = new ANTLRInputStream(this.input);
            QueryLexer lexer = new QueryLexer(input);
            CommonTokenStream tokens = new CommonTokenStream(lexer);
            QueryParser parser = new QueryParser(tokens);
            ParseTree tree = parser.query();
            return this.visit(tree);
        } catch (Exception cause) {
            throw new HandleException(cause);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Query dispatchBareToken(QueryHandler.Context context) throws HandleException {
        return this.engine.dispatchBareToken(context);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Query dispatchQuotedToken(QueryHandler.Context context) throws HandleException {
        return this.engine.dispatchQuotedToken(context);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void fetch(Reader input) {
        this.input = input;
    }
}
